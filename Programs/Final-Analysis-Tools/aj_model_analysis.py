import os
import numpy as np
import matplotlib.pyplot as plt
from  scipy.io import readsav
#from plotly.subplots import make_subplots
from matplotlib import gridspec
import matplotlib.patches as mpatches

def get_dirs_list(rootdir):
	'''
		A tiny function that scan a directory in order to find all of 
		its sub directories
	'''
	#print('os.scandir(rootdir)=', os.scandir(rootdir))
	dirs = [f.path for f in os.scandir(rootdir) if f.is_dir()]
	return dirs

def gen_data_filename(d, index):
	'''
		Generate a string with a syntax consistent with filenames generated by the IDL PostMCMC program 
	'''
	err=False
	if index < 10:
		s=d+'00' + str(index) + '.sav'
	if index >= 10 and index < 100:
		s=d+'0' + str(index) + '.sav'
	if index >=100 and index < 1000:
		s=d + str(index) + '.sav'
	if index >=1000:
		s='Cannot handle index numbers greater than 999'
		err=True
	return s, err

def read_sav(dir, ind):
	'''
		Read an IDL sav file that is generated by the IDL PostMCMC program
	'''
	s, err=gen_data_filename(dir, ind)
	if err == True:
		print(s)
		exit()
	else:
		r=readsav(s)
	return r['param'], len(r['param'])

def read_parameters_length(dir, param_file):
	'''
		Read the text file that contains the parameters structure and that is generated by the IDL PostMCMC program
	'''
	plength=[]
	with open(dir + param_file, 'r') as f:
		# Skip initial comments that starts with #
		for line in f:
				plength.append(line) # Each line contains a single value

	plength=np.array(plength, dtype=int)
	return plength

def read_combi(file):
	''' 
		Program dedicated to the reading of the Combination files that are generated by the Spectra-Simulator program
	'''
	pnames_done=False
	f=open(file, 'r')
	txt=f.read()
	f.close()
	txt=txt.split('\n')
	data=[]
	for t in txt:
		s=t.split()
		if s != '' and s !=[]:
			if s[0] != '':
				if s[0] == 'model_name=':
					model_name=s[1]
				if s[0] == '#': # This is the labels
					if pnames_done == False:
						params_names=s[1:]#.split()
						pnames_done=True
					else:
						print('Error: For some reason, there was more than one indicator of label. The label indicator is a #')
						print('       Be sure not to edit the Combinations.txt generated by the Spectra-Simulator program')
						exit()
				else: # This must be the data
					if pnames_done == True:
						data.append(s)
	return data, params_names, model_name

def read_rot_aj(d, i0_aj, ignore_slope=False):
	'''
		Read the rotation parameters of the MS_Global_aj_Harvey_like model (available in TAMCMC version>1.70)
		The use specifies the directory of the sav file (d), the initial index at which rotation parameters are stored
		(i0_aj) and can decide to skip the reading of the parameters that handle the slope with frequency of the aj parameters
		(ignore_slope) if they wish so. Note that grid analysis of a-coefficients show that although there is a slope, this one
		does not improve the inference on the activity region if aj ~ aj_CF + aj_AR(theta, delta) (See Benomar+2022). This is why
		by default the slope is usually fixed to 0 in the TAMCMC code.
	'''
	jmax=6 # Maximum order for the a-coefficient
	Naj=2 # Number of paramters for each aj
	a1_param, Nsize=read_sav(d, i0_aj)
	if ignore_slope == False:
		aj_param=np.zeros((jmax, Naj, Nsize))
		cpt=i0_aj
		for j in range(0,jmax):
			for i in range(Naj):
				samples, N=read_sav(d, i0_aj+cpt)
				aj_param[j, i,:]=samples
				cpt=cpt+1
	else:
		aj_param=np.zeros((jmax, Nsize))
		for j in range(0,jmax):
				samples, N=read_sav(d, i0_aj+Naj*j)
				aj_param[j,:]=samples
	return aj_param

def read_inc(d, i0_inc):
	inc, Nsize=read_sav(d, i0_inc)
	return inc

def make_stats(samples, confidence=[2.25,16,50,84,97.75]):
	N=len(samples)
	s=np.sort(samples)
	cdf = 100.*np.array(range(N))/float(N) # in %
	r=np.interp(confidence, cdf, s)
	return r

def make_error_from_stats(stats):
	err=np.zeros((2, len(stats[:,0]))) 
	err[0,:]=stats[:, 2] - stats[:, 1]
	err[1,:]=stats[:, 3] - stats[:, 2]
	return err

def get_aj_inc_star(rootdir, confidence=[2.25,16,50,84,97.75]):
	''' 
	This program specifically analyse the results of a single star and extract information on aj coefficients
	Which are useful for a bias analysis or an ensemble analysis of aj coefficients. This means:
		- Samples of all aj-coefficients
		- Statistics at different confidence intervals (equivalent to +/- 1sigma and +/- 2 sigma)
	Note that it uses outputs generated by the IDL postMCMC program
	'''
	# Getting all of the indexes required for the process
	print("		1.  Preparing data..")
	param_file='plength.txt'
	plength=read_parameters_length(rootdir + '/Files/', param_file) # Read the parameters_length file and retrieves plength
	#Nf_el=plength[2:6] # Elements 2,3,4 and 5
	#i0_freq=sum(plength[0:2]) # Sum of elements 0 and 1 which are Nmax and lmax
	#print("plength: ", plength)
	i0_aj=sum(plength[0:6]) # First Position after Nf_el list
	i0_inc=sum(plength[0:-2]) # The last parameter is before the extra parameters that are at the end ([-1] position)
	#
	# Get the rotation parameters in form of samples
	print("		2. Gathering rotation parameters...")
	aj_samples=read_rot_aj(rootdir + 'Files/', i0_aj, ignore_slope=True) 
	jmax=len(aj_samples[:,0])
	#
	# Get the inclination in form of samples
	print("		3. Gathering inclination parameters...")
	inc_samples=read_inc(rootdir + 'Files/', i0_inc)
	#
	# Extract basic statistics from the aj samples and frequency samples
	print("		4. Get stats using the samples of all of the parameters...")
	Nconfidence=len(confidence)
	aj_stats=np.zeros((jmax, Nconfidence))
	for j in range(0, jmax):
		aj_stats[j,:]=make_stats(aj_samples[j,:], confidence=confidence)
	inc_stats=make_stats(inc_samples)
	#
	return aj_stats, inc_stats, aj_samples, inc_samples, len(inc_samples)

def lookup_combi(key, combi_data, param_names, return_index=False):
	'''
		Look for a keyword 'key' inside param_names and returns the column of data associated to that key
		If the key does not exist, an error is returned.
		return_index: If True, returns only the index at which the key exists instead of the column
	'''
	index=param_names.index(key)
	tab=[]
	if return_index == False:
		for c in combi_data:
			tab.append(c[index])
		return tab
	else:
		return index

def bias_pdf(samples, xlabel, ylabel, text, xtrue=None, Ncols=3, Nrows=3, file_out='bias'):
	'''
		Function that receives a 2D array containing samples ('samples') for each parameters
		For each parameter, a pdf is shown in a single-page that contains (Ncols,Nrows) fields.
		xlabel: Defines the name of the x-axis (name of the parameter)
		ylabel: Defines the name of the y-axis (PDF)
		file_out: root name/directory for the image
		text: Any kind of text that we would like to be embeded inside the image of each field
		xtrue: If set, provides the value of the true input. It must be of same size as the number of parameters
	'''
	bins=30#75
	Nparams=len(samples[:,0]) # Ninc
	#	
	# Evaluate uncertainties using the samples
	errors=np.zeros((2,Nparams))
	med=np.zeros(Nparams)
	for i in range(Nparams):
		stats = np.percentile(samples[i,:], [16, 50, 84])
		#print(' stats[',i,'] = ', stats)
		errors[0,i]=stats[1] - stats[0]
		errors[1,i]=stats[2] - stats[1]
		med[i]=stats[1]
	#
	cpt=0
	fig_1d, ax = plt.subplots(Ncols,Nrows, figsize=(12, 6))
	for i in range(Ncols):
		for j in range(Nrows):
			h=ax[i,j].hist(samples[cpt,:],bins=bins)
			#pos=np.where(np.bitwise_and(h[1] >= med[cpt] - errors[0,cpt], h[1] <= med[cpt] + errors[1,cpt]))
			#ax[i,j].fill(h[1][pos], h[0][pos], color='gray')
			if j == Nrows: # Put the label only once, at the bottom of the plots
				ax[i,j].set_xlabel(xlabels)
			if i == Ncols: # Put the label only on the left side of the plots
				ax[i,j].set_ylabel("PDF")
			#print("[{}]   med[{}] = {}".format(cpt, cpt, med[cpt]))
			#print("     xtrue[{}] = {}".format(cpt, xtrue[cpt]))		
			ax[i,j].axvline(x=med[cpt], color='blue', linestyle='-')
			ax[i,j].axvline(x=med[cpt]-errors[0,cpt], color='gray', linestyle='--')
			ax[i,j].axvline(x=med[cpt]+errors[1,cpt], color='gray', linestyle='--')
			ax[i,j].axvline(x=xtrue[cpt], color='red')
			ax[i,j].text(0.8,0.8, text[cpt], fontsize = 10, horizontalalignment='center', verticalalignment='center', transform = ax[i,j].transAxes)
			cpt=cpt+1
	fig_1d.savefig(file_out+'_pdf.jpg')
	plt.close('all')

def bias_analysis_v1(MCMCdir, combi_file, fileout='plot'):
	'''
		Note on v1 version: This version shows a single Scenario (eg Polar case OR Equatorial case). In that sense, it 
							can only accept one MCMCdir and one combi_file
							To Show multiple scenarii in a single plot, use the bias_analysis_v2()
		This program gather informations on aj from a rootdirectory that contains an ensemble of simulations and 
		compare them with true inputs provided by a 'Combinations.txt' file. 
		The Combination file is generated by the Spectrum-Simulator as per specified by the configuration of the simulator:
		(see https://github.com/OthmanB/Spectra-Simulator-C)
		The outputs are:
			- A table of all the aj compared to the true inputs [NOT IMPLEMENTED]
			- Plots showing aj in function of inclination
	'''
	confidence=[2.25,16,50,84,97.75]
	jmax=6
	unit_nHz=1000 # Multiplicator to get units in nHz
	#
	print('A. Reading the Combinations file...')
	combi_data, param_names, model_name=read_combi(combi_file)
	Ncombi=len(combi_data)
	#print('B. Identify the directories in the rootdir...')
	#list_dirs=get_dirs_list(MCMCdir) 
	#print(list_dirs)
	print('B. Extracting aj and inclinations for each directory of that has a name that match the ID name in the combi_file... ')
	
	aj_data=np.zeros((Ncombi,jmax, len(confidence)))
	inc_data=np.zeros((Ncombi, len(confidence)))
	for i in range(Ncombi):
		stardir=MCMCdir + '/' + combi_data[i][0] + '.0/' # That should be a sequence of numbers that identify the simulation
		print('  --------')
		print('  star:', combi_data[i][0])
		print('  --------')
		aj_stats, inc_stats, aj_spl, inc_spl, Nsamples=get_aj_inc_star(stardir, confidence=confidence)
		aj_data[i,:,:]=aj_stats*unit_nHz
		inc_data[i,:]=inc_stats
		if i == 0:
			aj_samples=np.zeros((Ncombi, jmax, Nsamples))
			inc_samples=np.zeros((Ncombi, Nsamples))
		aj_samples[i,:,:]=aj_spl*unit_nHz
		inc_samples[i,:]=inc_spl
	print('C. Plots of bias...')
	inc_true=np.asarray(lookup_combi('i', combi_data, param_names), dtype=float)
	inc0=30 # Reject any plot of bias below inc0
	posOK=np.where(inc_true >= inc0)
	Ninc=len(inc_true)
	for j in range(0,jmax):
		print(" j=", j+1, ":")
		print("    1. Bias as a function of inclination")
		yr=[-1000, 1000] # Default yrange
		if j+1 != 1:
			aj_true=np.asarray(lookup_combi('a'+str(j+1), combi_data, param_names), dtype=float)*unit_nHz
			if j+1 == 2:
				yr=[-250, 250]
			if j+1 == 4:
				yr=[-20, 20]				
		else: # a1_true is not an explicit parameter. There is two choice: Use a1ovGamma*Gamma_at_numax or set it manually.
			a1ovGamma=np.asarray(lookup_combi('a1ovGamma', combi_data, param_names), dtype=float)
			Gamma_at_numax=np.asarray(lookup_combi('Gamma_at_numax', combi_data, param_names), dtype=float)
			a1_true=a1ovGamma * Gamma_at_numax*unit_nHz
			aj_true=np.zeros(Ninc) + a1_true
			yr=[np.min(aj_true[posOK])*0.1, np.max(aj_true[posOK])*1.1]
		minfill=min(yr)
		fig ,ax= plt.subplots(tight_layout=True)
		ax.set_xlabel('Inclination (deg)')
		#ax.set_ylabel('$a_'+str(j+1)+' - a_'+str(j+1) + '^{(true)}$ (nHz)')
		ax.set_ylabel('$a_'+str(j+1) + '$ (nHz)')
		ax.plot(inc_true, aj_true, linestyle='dashed',dashes=(5, 10)) # Horizontal line
		#yr=[min([np.min(aj_true[posOK]), np.min(aj_data[posOK,j,2])]), max([np.max(aj_true[posOK]), np.max(aj_data[posOK,j,2])])]
		ax.set_ylim(yr[0], yr[1])
		ax.set_xlim(-5, 95)
		yerr=make_error_from_stats(aj_data[:,j,:])
		xerr=make_error_from_stats(inc_data[:,:])
		#ax.errorbar(inc_data[posOK,2], aj_data[posOK,j, 2], xerr=xerr[posOK], yerr=yerr[posOK])
		for i in range(Ninc):
			if inc_true[i] >= inc0:
				ax.annotate("", xy=(inc_data[i,2], aj_data[i,j,2]), xytext=(inc_true[i], aj_true[i]), va="center", ha="center", arrowprops={"arrowstyle": "-|>"})
		plt.fill_between([0, inc0], [yr[1],yr[1]], minfill, color='gray')
		plt.savefig(fileout+'_a'+str(j+1)+'.png', dpi=300)
		plt.close('all')
		#
		print("    2. Bias for each aj (PDF)")
		xlabel='$a_'+str(j+1) + '$ (nHz)'
		ylabel='PDF'
		i0=1 # Ignore the inclination=0 to have a (3,3) = 9 Plot
		text=[]
		for i in range(i0,len(inc_true)):
			text.append('inc='+str(inc_true[i]))
		bias_pdf(aj_samples[i0:,j,:], xlabel, ylabel, text, xtrue=aj_true[i0:], Ncols=3, Nrows=3, file_out=fileout + '_bias_a'+str(j+1))

def bias_analysis_v2(MCMCdir, combi_files, labels=None, fileout='plot', col_arrows=None):
	'''
		Note on v2 version: This version shows multiple scenarii in a single plot, use the bias_analysis_v2()
							To Show a single Scenario (eg Polar case OR Equatorial case) use bias_analysis_v1()
		This program gather informations on aj from a rootdirectory that contains an ensemble of simulations and 
		compare them with true inputs provided by a 'Combinations.txt' file. 
		The Combination file is generated by the Spectrum-Simulator as per specified by the configuration of the simulator:
		(see https://github.com/OthmanB/Spectra-Simulator-C)
		The outputs are:
			- A table of all the aj compared to the true inputs [NOT IMPLEMENTED]
			- Plots showing aj in function of inclination
			- Plots showing aj PDFS with an indicator of the true input
	'''
	confidence=[2.25,16,50,84,97.75]
	jmax=6
	unit_nHz=1000 # Multiplicator to get units in nHz
	inc0=30 # Reject any plot of bias below inc0
	#
	print('A. Reading the Combinations files...')
	combi_data=[]
	param_names=[]
	model_name=[]
	Ncombi=[]
	for c in combi_files:
		c_data, p_names, m_name=read_combi(c)
		combi_data.append(c_data)
		param_names.append(p_names)
		model_name.append(m_name)
		Ncombi.append(len(c_data))
	Nscenario=len(Ncombi)
	if col_arrows == None:
		col_arrows=np.repeat('Black', Nscenario)	
	if labels != None:
		patches=[]
		for k in range(0, Nscenario):
			patches.append(mpatches.Patch(color=col_arrows[k], label=labels[k]))

	col_l=['black', 'dimgray']
	col_lines=[['black', 'black']]
	for j in range(1, jmax):
		col_lines.append(col_l)
	print('B. Extracting aj and inclinations for each directory of that has a name that match the ID name in the combi_files... ')
	aj_data=[]
	inc_data=[]
	aj_samples=[]
	inc_samples=[]
	for k in range(Nscenario):
		print('  ********** SCENARIO {} **********  '.format(k))
		print('  MCMCdir =', MCMCdir[k])
		print('  *********************************  ')
		aj_data.append(np.zeros((Ncombi[k],jmax, len(confidence))))
		inc_data.append(np.zeros((Ncombi[k], len(confidence))))
		for i in range(Ncombi[k]):
			stardir=MCMCdir[k] + '/' + combi_data[k][i][0] + '.0/' # That should be a sequence of numbers that identify the simulation
			print('  --------')
			print('  star:', combi_data[k][i][0])
			print('  --------')
			aj_stats, inc_stats, aj_spl, inc_spl, Nsamples =get_aj_inc_star(stardir, confidence=confidence)
			aj_data[k][i,:,:]=aj_stats*unit_nHz
			inc_data[k][i,:]=inc_stats
			if i == 0:
				aj_samples.append(np.zeros((Ncombi[k], jmax, Nsamples)))
				inc_samples.append(np.zeros((Ncombi[k], Nsamples)))
			aj_samples[k][i,:,:]=aj_spl*unit_nHz
			inc_samples[k][i,:]=inc_spl

	print('C. Plots of bias...')
	inc_true=np.asarray(lookup_combi('i', combi_data[k], param_names[k]), dtype=float)
	posOK=np.where(inc_true >= inc0)
	Ninc=len(inc_true)
	for j in range(0,jmax):
		print(" j=", j+1, ":")
		yr=[-1000, 1000] # Default yrange
		if j+1 == 1:
			yr=[900, 1100]
		if j+1 == 2:
			yr=[-250, 250]
		if j+1 == 4:
			yr=[-20, 20]		
		fig ,ax= plt.subplots(tight_layout=True)
		ax.set_xlabel('Inclination (deg)')
		ax.set_ylabel('$a_'+str(j+1) + '$ (nHz)')
		ax.set_ylim(yr[0], yr[1])
		ax.set_xlim(-1, 91)
		#fig.set_label(labels[k])
		#plt.legend(labels=labels, color=col_arrows, loc="upper left")
		for k in range(Nscenario):
			if j+1 != 1:
				aj_true=np.asarray(lookup_combi('a'+str(j+1), combi_data[k], param_names[k]), dtype=float)*unit_nHz		
			else: # a1_true is not an explicit parameter. There is two choice: Use a1ovGamma*Gamma_at_numax or set it manually.
				a1ovGamma=np.asarray(lookup_combi('a1ovGamma', combi_data[k], param_names[k]), dtype=float)
				Gamma_at_numax=np.asarray(lookup_combi('Gamma_at_numax', combi_data[k], param_names[k]), dtype=float)
				a1_true=a1ovGamma * Gamma_at_numax*unit_nHz
				aj_true=np.zeros(Ninc) + a1_true
			minfill=min(yr)
			yerr=make_error_from_stats(aj_data[k][:,j,:])
			xerr=make_error_from_stats(inc_data[k][:,:])
			#ax.errorbar(inc_data[posOK,2], aj_data[posOK,j, 2], xerr=xerr[posOK], yerr=yerr[posOK])
			ax.plot(inc_true, aj_true, linestyle='dashed',dashes=(5, 10), color=col_lines[j][k]) # Horizontal line
			for i in range(Ninc):
				if inc_true[i] >= inc0:
					ax.annotate("", xy=(inc_data[k][i,2], aj_data[k][i,j,2]), xytext=(inc_true[i], aj_true[i]), color=col_arrows[k], va="center", ha="center", arrowprops={"arrowstyle": "-|>", "color":str(col_arrows[k])})
			plt.fill_between([0, inc0], [yr[1],yr[1]], minfill, color='silver')
		if labels != None:
			ax.legend(handles=patches, loc="upper left")
		plt.savefig(fileout+'_a'+str(j+1)+'.png', dpi=300)
		plt.close('all')

dir_root='/Users/obenomar/tmp/test_a2AR/tmp/data/'
combi_files=[dir_root +'HNR20_a1ovGamma0.5_Tobs730_Polar/Sources/Combinations.txt', dir_root+'HNR20_a1ovGamma0.5_Tobs730_Equatorial/Sources/Combinations.txt']

# Looking at the Learning phase	
#MCMCdir='/Users/obenomar/tmp/test_a2AR/tmp/data/HNR20_a1ovGamma0.5_Tobs730_Polar/postMCMC/Level1/L/'
#fileout='/Users/obenomar/tmp/test_a2AR/tmp/data/HNR20_a1ovGamma0.5_Tobs730_Polar/postMCMC/Level2/L/plot'
#
#MCMCdir='/Users/obenomar/tmp/test_a2AR/tmp/data/HNR20_a1ovGamma0.5_Tobs730_Equatorial/postMCMC/Level1/L/'
#fileout='/Users/obenomar/tmp/test_a2AR/tmp/data/HNR20_a1ovGamma0.5_Tobs730_Equatorial/postMCMC/Level2/L/plot'

# Looking at the Acquire phase
MCMCdir=[dir_root+'/HNR20_a1ovGamma0.5_Tobs730_Polar/postMCMC/Level1/A/', dir_root+'HNR20_a1ovGamma0.5_Tobs730_Equatorial/postMCMC/Level1/A/']
#fileout='/Users/obenomar/tmp/test_a2AR/tmp/data/HNR20_a1ovGamma0.5_Tobs730_Polar/postMCMC/Level2/A/plot'
fileout_all='/Users/obenomar/tmp/test_a2AR/tmp/data/Result_Summary/All_plot'
#fileout='/Users/obenomar/tmp/test_a2AR/tmp/data/HNR20_a1ovGamma0.5_Tobs730_Equatorial/postMCMC/Level2/A/plot'

#j=0
#bias_analysis_v1(MCMCdir[j], combi_file[j], fileout=fileout)

col_arrows=['cornflowerblue', 'deepskyblue']
labels=['Polar cap', 'Equatorial Band']
bias_analysis_v2(MCMCdir, combi_files, labels=labels, fileout=fileout_all, col_arrows=col_arrows)

