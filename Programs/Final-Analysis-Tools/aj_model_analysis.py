import os
import numpy as np
import matplotlib.pyplot as plt
from  scipy.io import readsav
#from plotly.subplots import make_subplots
from matplotlib import gridspec

def get_dirs_list(rootdir):
	'''
		A tiny function that scan a directory in order to find all of 
		its sub directories
	'''
	#print('os.scandir(rootdir)=', os.scandir(rootdir))
	dirs = [f.path for f in os.scandir(rootdir) if f.is_dir()]
	return dirs

def gen_data_filename(d, index):
	'''
		Generate a string with a syntax consistent with filenames generated by the IDL PostMCMC program 
	'''
	err=False
	if index < 10:
		s=d+'00' + str(index) + '.sav'
	if index >= 10 and index < 100:
		s=d+'0' + str(index) + '.sav'
	if index >=100 and index < 1000:
		s=d + str(index) + '.sav'
	if index >=1000:
		s='Cannot handle index numbers greater than 999'
		err=True
	return s, err

def read_sav(dir, ind):
	'''
		Read an IDL sav file that is generated by the IDL PostMCMC program
	'''
	s, err=gen_data_filename(dir, ind)
	if err == True:
		print(s)
		exit()
	else:
		r=readsav(s)
	return r['param'], len(r['param'])

def read_parameters_length(dir, param_file):
	'''
		Read the text file that contains the parameters structure and that is generated by the IDL PostMCMC program
	'''
	plength=[]
	with open(dir + param_file, 'r') as f:
		# Skip initial comments that starts with #
		for line in f:
				plength.append(line) # Each line contains a single value

	plength=np.array(plength, dtype=int)
	return plength

def read_combi(file):
	''' 
		Program dedicated to the reading of the Combination files that are generated by the Spectra-Simulator program
	'''
	pnames_done=False
	f=open(file, 'r')
	txt=f.read()
	f.close()
	txt=txt.split('\n')
	data=[]
	for t in txt:
		s=t.split()
		if s != '' and s !=[]:
			if s[0] != '':
				if s[0] == 'model_name=':
					model_name=s[1]
				if s[0] == '#': # This is the labels
					if pnames_done == False:
						params_names=s[1:]#.split()
						pnames_done=True
					else:
						print('Error: For some reason, there was more than one indicator of label. The label indicator is a #')
						print('       Be sure not to edit the Combinations.txt generated by the Spectra-Simulator program')
						exit()
				else: # This must be the data
					if pnames_done == True:
						data.append(s)
	return data, params_names, model_name

def read_rot_aj(d, i0_aj, ignore_slope=False):
	'''
		Read the rotation parameters of the MS_Global_aj_Harvey_like model (available in TAMCMC version>1.70)
		The use specifies the directory of the sav file (d), the initial index at which rotation parameters are stored
		(i0_aj) and can decide to skip the reading of the parameters that handle the slope with frequency of the aj parameters
		(ignore_slope) if they wish so. Note that grid analysis of a-coefficients show that although there is a slope, this one
		does not improve the inference on the activity region if aj ~ aj_CF + aj_AR(theta, delta) (See Benomar+2022). This is why
		by default the slope is usually fixed to 0 in the TAMCMC code.
	'''
	jmax=6 # Maximum order for the a-coefficient
	Naj=2 # Number of paramters for each aj
	a1_param, Nsize=read_sav(d, i0_aj)
	if ignore_slope == False:
		aj_param=np.zeros((jmax, Naj, Nsize))
		cpt=i0_aj
		for j in range(0,jmax):
			for i in range(Naj):
				samples, N=read_sav(d, i0_aj+cpt)
				aj_param[j, i,:]=samples
				cpt=cpt+1
	else:
		aj_param=np.zeros((jmax, Nsize))
		for j in range(0,jmax):
				samples, N=read_sav(d, i0_aj+Naj*j)
				aj_param[j,:]=samples
	return aj_param

def read_inc(d, i0_inc):
	inc, Nsize=read_sav(d, i0_inc)
	return inc

def make_stats(samples, confidence=[2.25,16,50,84,97.75]):
	N=len(samples)
	s=np.sort(samples)
	cdf = 100.*np.array(range(N))/float(N) # in %
	r=np.interp(confidence, cdf, s)
	return r

def make_error_from_stats(stats):
	err=np.zeros((2, len(stats[:,0]))) 
	err[0,:]=stats[:, 2] - stats[:, 1]
	err[1,:]=stats[:, 3] - stats[:, 2]
	return err

def get_aj_inc_star(rootdir, confidence=[2.25,16,50,84,97.75]):
	''' 
	This program specifically analyse the results of a single star and extract information on aj coefficients
	Which are useful for a bias analysis or an ensemble analysis of aj coefficients. This means:
		- Samples of all aj-coefficients
		- Statistics at different confidence intervals (equivalent to +/- 1sigma and +/- 2 sigma)
	Note that it uses outputs generated by the IDL postMCMC program
	'''
	# Getting all of the indexes required for the process
	print("		1.  Preparing data..")
	param_file='plength.txt'
	plength=read_parameters_length(rootdir + '/Files/', param_file) # Read the parameters_length file and retrieves plength
	#Nf_el=plength[2:6] # Elements 2,3,4 and 5
	#i0_freq=sum(plength[0:2]) # Sum of elements 0 and 1 which are Nmax and lmax
	#print("plength: ", plength)
	i0_aj=sum(plength[0:6]) # First Position after Nf_el list
	i0_inc=sum(plength[0:-2]) # The last parameter is before the extra parameters that are at the end ([-1] position)
	#
	# Get the rotation parameters in form of samples
	print("		2. Gathering rotation parameters...")
	aj_samples=read_rot_aj(rootdir + 'Files/', i0_aj, ignore_slope=True) 
	jmax=len(aj_samples[:,0])
	#
	# Get the inclination in form of samples
	print("		3. Gathering inclination parameters...")
	inc_samples=read_inc(rootdir + 'Files/', i0_inc)
	#
	# Extract basic statistics from the aj samples and frequency samples
	print("		4. Get stats using the samples of all of the parameters...")
	Nconfidence=len(confidence)
	aj_stats=np.zeros((jmax, Nconfidence))
	for j in range(0, jmax):
		aj_stats[j,:]=make_stats(aj_samples[j,:], confidence=confidence)
	inc_stats=make_stats(inc_samples)
	#
	return aj_stats, inc_stats

def lookup_combi(key, combi_data, param_names, return_index=False):
	'''
		Look for a keyword 'key' inside param_names and returns the column of data associated to that key
		If the key does not exist, an error is returned.
		return_index: If True, returns only the index at which the key exists instead of the column
	'''
	index=param_names.index(key)
	tab=[]
	if return_index == False:
		for c in combi_data:
			tab.append(c[index])
		return tab
	else:
		return index

def bias_analysis(MCMCdir, combi_file, fileout='plot'):
	'''
		This program gather informations on aj from a rootdirectory that contains an ensemble of simulations and 
		compare them with true inputs provided by a 'Combinations.txt' file. 
		The Combination file is generated by the Spectrum-Simulator as per specified by the configuration of the simulator:
		(see https://github.com/OthmanB/Spectra-Simulator-C)
		The outputs are:
			- A table of all the aj compared to the true inputs
			- Plots showing aj in function of inclination
	'''
	confidence=[2.25,16,50,84,97.75]
	jmax=6
	#
	print('A. Reading the Combinations file...')
	combi_data, param_names, model_name=read_combi(combi_file)
	Ncombi=len(combi_data)
	#print('B. Identify the directories in the rootdir...')
	#list_dirs=get_dirs_list(MCMCdir) 
	#print(list_dirs)
	print('B. Extracting aj and inclinations for each directory of that has a name that match the ID name in the combi_file... ')
	
	aj_data=np.zeros((Ncombi,jmax, len(confidence)))
	inc_data=np.zeros((Ncombi, len(confidence)))
	for i in range(Ncombi):
		stardir=MCMCdir + '/' + combi_data[i][0] + '.0/' # That should be a sequence of numbers that identify the simulation
		print('  --------')
		print('  star:', combi_data[i][0])
		print('  --------')
		aj_stats, inc_stats=get_aj_inc_star(stardir, confidence=confidence)
		aj_data[i,:,:]=aj_stats
		inc_data[i,:]=inc_stats
	print('C. Plots...')
	inc_true=np.asarray(lookup_combi('i', combi_data, param_names), dtype=float)
	Ninc=len(inc_true)
	for j in range(0,jmax):
		if j+1 != 1:
			aj_true=np.asarray(lookup_combi('a'+str(j+1), combi_data, param_names), dtype=float)
		else: # a1_true is not an explicit parameter. There is two choice: Use a1ovGamma*Gamma_at_numax or set it manually.
			a1ovGamma=np.asarray(lookup_combi('a1ovGamma', combi_data, param_names), dtype=float)
			Gamma_at_numax=np.asarray(lookup_combi('Gamma_at_numax', combi_data, param_names), dtype=float)
			a1_true=a1ovGamma * Gamma_at_numax
			aj_true=np.zeros(Ninc) + a1_true
		fig ,ax= plt.subplots(tight_layout=True)
		ax.set_xlabel('Inclination (deg)')
		#ax.set_ylabel('$a_'+str(j+1)+' - a_'+str(j+1) + '^{(true)}$ (nHz)')
		ax.set_ylabel('$a_'+str(j+1) + ' (nHz)')
		ax.plot(inc_true, aj_true, linestyle='dashed',dashes=(5, 10)) # Horizontal line
		ax.set_ylim(min([np.min(aj_true), np.min(aj_data[:,j,2])]), max([np.max(aj_true), np.max(aj_data[:,j,2])]))
		ax.set_xlim(-5, 95)
		#yerr=make_error_from_stats(aj_data[:,j,:])
		#xerr=make_error_from_stats(inc_data[:,:])
		#ax.errorbar(inc_data[:,2], aj_data[:,j, 2], xerr=xerr, yerr=yerr)
		for i in range(Ninc):
			ax.annotate("", xy=(inc_data[i,2], aj_data[i,j,2]), xytext=(inc_true[i], aj_true[i]), va="center", ha="center", arrowprops={"arrowstyle": "-|>"})
		plt.savefig(fileout+'_a'+str(j+1)+'.png', dpi=300)
		plt.close('all')
	#plt.show()

combi_file='/Users/obenomar/tmp/test_a2AR/tmp/data_test/HNR20_a1ovGamma0.5_Tobs730_Polar/Source/Configuration/Combinations.txt'
MCMCdir='/Users/obenomar/tmp/test_a2AR/tmp/data_test/HNR20_a1ovGamma0.5_Tobs730_Polar/results/level1/'
bias_analysis(MCMCdir, combi_file)

