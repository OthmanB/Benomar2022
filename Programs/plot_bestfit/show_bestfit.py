'''
    A set of functions to allow you to show the best fit on the data
'''
import os
import numpy as np
from read_outputs_tamcmc import bin2txt, read_datafile, getmodel_bin
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter
from scipy.interpolate import interp1d
from function_rot import amplitude_ratio
from harvey import noise_harvey
from signal_significance_chi2p import signal_significance_chi2p

def get_data(file_data, i_x=0, i_y=1):
    '''
        A function that extract the data file used as a constrain
        file_data: The name of the data file that contains the data to be fitted. It can also
            be a zip file with the data file within it
        i_x, i_y, i_err: The indexes at which the x,y and error axis are to be found
    '''
    matrix,header=read_datafile(file_data)
    Ncols = len(matrix[0,:])
    if Ncols < 2:
        print("Error: The data file must at least contain x and y axis values")
        print("       However, only one column was detected")
        print("       Please check your file")
        exit()
    if Ncols == 2:
        return matrix[:,i_x],matrix[:,i_y], header
    if Ncols >=3:
        print('Warning: The data file contains more than two columns. We will return only')
        print("         The three corresponding to i_x={}, i_y={}".format(i_x, i_y))
        return matrix[:,i_x],matrix[:,i_y], header
    return [-1], [-1], ''

def get_bestparams(dir_mcmc, process_name, filter_params=[], best_criteria='median',
                phase='A', chain=0, first_index=0, period=1, cpp_path='cpp_prg/', tmp_samples='tmp/'):
    '''
        A function that read the MCMC results and extract the best parameters of the fit
        dir_tamcmc_outputs: Directory in which the output .bin files from the MCMC process can be found
        process_name: The name of the processes. Used to identify the files
        filter_params: A list of lists that give a way of selecting a subset of the parameter space
            Each sublist must have (1) the index of the parameter that is used for filtering the whole set
                                   (2) the minimum and (3) maximum range of data that is kept
                                   example: [[10, -1, 1]]: One filter, index=10, min/max:-1,1
        best_criteria: Either 'mean' or 'median'. Allows to define the criteria used to define the 'best fit'
        phase: The phase of the analysis. Typically either 'B', 'L' or 'A' (default is 'A')
        chain: The chain index. Related to the temperature. By default chain=0, which is the coldest chain (the target distribution)
        first_index: First sample index that is considered. Used to possibly remove burn-in (default is 0)
        period: The period at which we get the data. Default is 1. If set to higher than 1, it will jump some data. Used to 'compress' the chain and thus 
            read it faster.
    '''
    smcmc, labels, isfixed, plength=bin2txt(dir_mcmc, process_name, phase=phase, chain=chain, first_index=first_index,
        period=period, erase_tmp=True, cpp_path=cpp_path, outdir=tmp_samples, get_plength=True)
    fmcmc=smcmc
    Nparams=len(smcmc[0,:])
    Nsamples=len(smcmc[:,0])
    #print('Nparams:', Nparams)
    #print('Nsamples:', Nsamples)
    # Iteratively filter the data so that they match the requested conditions in filter_params
    for f in filter_params:
        condition=np.where(np.bitwise_and(fmcmc[:,f[0]] > f[1], fmcmc[:,f[0]] < f[2]))[0]
        fmcmc=fmcmc[condition,:]
    # Apply the mean or median to get the best fit
    best_params=np.zeros(Nparams)
    if best_criteria == 'mean':
        for i in range(Nparams):
            best_params[i]=np.mean(fmcmc[:,i])
    if best_criteria == 'median':
        for i in range(Nparams):
            best_params[i]=np.median(fmcmc[:,i])
    if best_criteria != 'median' and best_criteria != 'mean':
        print('Error: The best fit criteria is not recognized. Please set best_criteria to either "mean" or "median"')
        print("       The program will exit now")
    return best_params, plength, labels

def get_model(process_info, filter_params=[], best_criteria='median', phase='A', chain=0, first_index=0, period=1, cpp_path='cpp_prg/'):
    '''
        Function that provided inputs of the MCMC run, derives the model
        associated to it.
        process_info: A dictionary that must contain: 
            - dir_mcmc: The directory of all the output data
            - process_name: The name of the process. Used to identify the specific MCMC run
            - phase: The phase. Usually either 'B', 'L' or 'A'
            - chain: The chain index. The coldest chain is 0
            - model_name: The name of the model that was executed during the MCMC run
            - file_data (optional): The file containing the data (either the .data or the zip generated by the TAMCMC process).
                If set to file_data='', the program will search into the inputs_backup directory for the zip backup file and read it
            - data_i_x: The index in the data file at which the x-axis is
            - data_i_y: The index in the data file at which the y-axis is
        filter_params: A list of lists that give a way of selecting a subset of the parameter space
            Each sublist must have (1) the index of the parameter that is used for filtering the whole set
                                   (2) the minimum and (3) maximum range of data that is kept
                                   example: [[10, -1, 1]]: One filter, index=10, min/max:-1,1
        best_criteria: Either 'mean' or 'median'. Allows to define the criteria used to define the 'best fit'
        first_index: First sample index that is considered. Used to possibly remove burn-in (default is 0)
        period: The period at which we get the data. Default is 1. If set to higher than 1, it will jump some data. Used to 'compress' the chain and thus 
            read it faster.
    '''
    cpath=os.getcwd()
    # Extract the data
    if process_info['file_data'] == '':
        file_data=process_info['dir_mcmc'] + process_info['process_name'] + "/inputs_backup/data_backup.zip"
    else:
        file_data=process_info['file_data']
    x_data,y_data, header=get_data(file_data, i_x=process_info['data_i_x'], i_y=process_info['data_i_y'])
    if x_data[0] == -1 and y_data[0] == -1 and header =='':
        print('Error in get_model(): get_data returned -1. There might be a problem in the file structure.')
        print('      Debug required')
        exit()
    # Compute the set of best parameters
    bestparams, plength, labels=get_bestparams(process_info['dir_mcmc'], process_info['process_name'], filter_params=filter_params, best_criteria='median',
                phase=process_info['phase'], chain=process_info['chain'], first_index=first_index, period=period)
    #for i in range(len(bestparams)):
    #    print(labels[i], '    ', bestparams[i])
    #exit()
    # Derive the model. Here it is generated for all of the data range
    xr=[np.min(x_data), np.max(x_data), x_data[2]-x_data[1]] # set the model minimum and maximum frequency along with the resolution to be the same as the data
    x_model,y_model, params_dic=getmodel_bin(process_info['model_name'], bestparams, plength, xr, cpp_path=cpp_path, outdir=cpath+'/tmp/', read_output_params=True)
    return x_data, y_data, x_model, y_model, params_dic

def show_residual(ax, data_x, data_y, model_x, model_y, main_params):
    func=interp1d(model_x, model_y, kind='linear', fill_value="extrapolate") # Using interpolation here to resolve any tiny mismatch in size. Usually the mismatch is < 2 bins only
    model_y_interp=func(data_x) # The model interpolated at the position of the data
    residuals=data_y/model_y_interp
    resol=data_x[1] - data_x[0]
    sfactor=int(main_params['scoef']/resol) # Smooth over smooth_fact, in microHz
    residu_s1=gaussian_filter(residuals, sfactor, mode='mirror')
    residu_s10=gaussian_filter(residuals, 10*sfactor, mode='mirror')
    #
    # Get the significance level at 90%
    level=95
    s1, Proba=signal_significance_chi2p(background=1, p=sfactor, level=level, fall_back=True, do_fall_back=False, exit_on_error=False)
    s10, Proba=signal_significance_chi2p(background=1, p=10*sfactor, level=level, fall_back=True, do_fall_back=False, exit_on_error=False)
    ax.text(main_params['xmax'], s1, '{0:.0f}%'.format(level) , verticalalignment='bottom', horizontalalignment='left', color='darkgray', fontsize=7)
    ax.text(main_params['xmax'], s10, '{0:.0f}%'.format(level) , verticalalignment='bottom', horizontalalignment='left', color='red', fontsize=7)
    label_s1=r's ={0:.0f} nHz'.format(main_params['scoef']*1000)
    label_s10=r's ={0:.0f} nHz'.format(10*main_params['scoef']*1000)
    ax.plot(data_x, residu_s1, color='gray', linewidth=0.8, label=label_s1)
    ax.plot(data_x, residu_s10, color='red', linewidth=0.8, label=label_s10)
    ax.axhline(y=1, linestyle='-', linewidth=1., color='black')
    ax.axhline(y=s1, linestyle='--', linewidth=1., color='darkgray')
    ax.axhline(y=s10, linestyle='--', linewidth=1., color='red')
    ax.set_xlim(main_params['xmin'], main_params['xmax'])
    ax.set_ylim(0,2.4)
    ax.set_xlabel('Frequency ('+r'$\mu$'+ 'Hz)', fontsize=7)
    ax.set_ylabel('residuals', fontsize=7)
    ax.tick_params(axis='x', labelsize=7)
    ax.tick_params(axis='y', labelsize=7)
    #axes[1].text(0.02, 0.95, 'mean = {0:.4f}'.format(np.mean(residu_s1)) , verticalalignment='bottom', horizontalalignment='left', transform=axes[1].transAxes, color='Black', fontsize=7)
    ax.legend(fontsize=6, loc='lower right')


def show_model(freq, spec, xmodel, model, params_dic=[], xmodel_ref=[], model_ref=[], params_dic_ref=[], freq_range=['Auto'], smooth_fact=None, ax=[], tag_modes_on_axis=False, tag_modes='all'):
    '''
        Function that shows the model superimposed on data. 
        freq: x-values. Typically Frequencies
        spec: y-values. Typically Power in ppm^2/microHz
        xmodel and model: The x and y-axis for the model. Will be superimposed on (freq,spec)
        xmodel_ref and model_ref (optional): If given, show a reference model superimposed on (freq, spec) and on (xmodel, model). 
        params_dic: Full set of parameters, as read out from a params.model file created by getmodel. These are available structured 
                    so that it is easy to extract frequencies, heights, etc... Used for tagging the modes and for defining the visualisation
                    range in the Auto mode.
        stats_dic: Dictionary for the statistics for the Full set of parameters (in the 'raw' key) + some computed combination of those parameters in the 'extra' key (eg. Dnu_p for mixed modes models)
        params_dic_ref (optional): Full set of parameters for the reference model
        smooth_fact: factor of smoothing over the x-axis for the observational data. Given in unit of the x-axis (eg. microHz)
        ax (optional): If given, must be a list of 2 axes created by matplotlib. This will define the drawing zones for the model and for the diagnostic data
        tag_modes_on_axis: If True, put the frequencies of the modes in the x-axis instead of on the modes. Could give a clearer plot when (fmax-fmax)/Dnu is large
        tab_modes: Either 'all', 'simple', 'none'. 
                If 'all', shows the frequencies in labels, bars for each m-components and their rank number (radial order) by increasing frequency and the smoothing information as well as critical info (inc<20 warning)
                If 'simple', shows only the bars for each m-components and the smoothing information as well as critical info (inc<20 warning)
                If 'basic', shows only the smoothing information as well as critical info (inc<20 warning)
                If 'critical', shows only the critical info (inc<20 warning)
                If 'none', shows only the spectrum and its fit
    '''
    # --- Temporary Variables ---
    Nmed= [-1, -1, -1, -1]

    # --- Setup ----
    do_show=False
    # Identify usefull columns and return error in case we do not find what we expect
    try:
        col_l=params_dic["modes"]["param_names"].index('degree')
        col_f=params_dic["modes"]["param_names"].index("freq")
        col_h=params_dic["modes"]["param_names"].index("H")
        col_w=params_dic["modes"]["param_names"].index("W")
        col_a1=params_dic["modes"]["param_names"].index("a1")
        col_inc=params_dic["modes"]["param_names"].index("inclination")
        #print(' col_l = ', col_l)
        #print(' col_f = ', col_f)
    except:
        print('Error: columns with degrees and/or with frequencies not identified in the params_dic within show_model()')
        print('       Expected (and used) keys in the dictionary: degree, freq, H, W, a1, inclination')
        print('       Check that your model use the correct names within the table created by getmodel')
        exit()
    # Linearize noise parameters so that later we can use the harvey calculation function to get the local noise
    if params_dic["noise"][0,0] == 0: # Case where the first Harvey is simply set to 0... no need to bother spending time to calculated it
        N=7
        i0=1
    else:
        i0=0
        N=10
    noise_params=np.zeros(N)
    c=0
    k=i0
    for i in range(N):
        #print(k,c)
        noise_params[i]=params_dic["noise"][k,c]
        if c >= 2:
            c=0
            k=k+1
        else:
            c=c+1    
    # Nmodes for l=0, 1, 2, 3 In the whole model
    pos_l=[np.where(params_dic["modes"]["params"][:,col_l] == 0)[0], np.where(params_dic["modes"]["params"][:,col_l] == 1)[0], 
        np.where(params_dic["modes"]["params"][:,col_l] == 2)[0], np.where(params_dic["modes"]["params"][:,col_l] == 3)[0]]
    Nmodes=[]
    Nmodes.append(len(pos_l[0])) 
    Nmodes.append(len(pos_l[1])) 
    Nmodes.append(len(pos_l[2])) 
    Nmodes.append(len(pos_l[3])) 
    # Calculate Dnu
    fl0=params_dic["modes"]["params"][pos_l[0],  col_f]   
    # Calculate Dnu
    #print('fl0 : ', fl0)
    #print('x   : ', np.linspace(0, len(fl0)-1, len(fl0)))
    xf=np.linspace(0, len(fl0)-1, len(fl0))
    fit,residu, rank, svd, rcond=np.polyfit(xf, fl0-np.min(fl0), 1, full=True)  # We compute the mean spacing through linear fiting.
    Dnu=fit[0]
    sigDnu=np.std(fl0 - np.min(fl0) - (fit[0]*xf + fit[1]))
    #print(Dnu, '  ',  sigDnu,  '  ', residu)
    # Define the ploting area
    if ax == []:
        fig, ax0 = plt.subplots(1, figsize=(12, 12))
        ax1=ax0
        do_show=True
    else:
        if len(ax) == 2:
            ax0=ax[0] # The zone for the model
            ax1=ax[1] # The zone for any text information (Dnu, DP, etc..)
        else:
            print('Error: ax is expected to contain two axis. ax0 and ax1')
            print('       show_model() cannot pursue')
            exit()
    if freq_range !=[]:
        if freq_range[0] == 'Auto': # Adjust the window to the min/max of the l=0 mode frequency minus/plus Dnu/2
            # Evaluate the automatic ranges
            freq_range= [np.min(fl0) - Dnu/2, np.max(fl0) + Dnu/2]
        pos=np.where(np.bitwise_and(freq>=freq_range[0], freq<=freq_range[1]))[0]
        x=freq[pos]
        y=spec[pos]
        pos=np.where(np.bitwise_and(xmodel>=freq_range[0], xmodel<=freq_range[1]))[0]
        xm=xmodel[pos]
        m=model[pos]
        # Number of modes within the specified shown window
        NWin=[]
        NWin.append(len(np.where(np.bitwise_and(params_dic["modes"]["params"][pos_l[0],  col_f] >=freq_range[0], params_dic["modes"]["params"][pos_l[0],  col_f]<=freq_range[1]))[0]))
        NWin.append(len(np.where(np.bitwise_and(params_dic["modes"]["params"][pos_l[1],  col_f] >=freq_range[0], params_dic["modes"]["params"][pos_l[1],  col_f]<=freq_range[1]))[0]))
        NWin.append(len(np.where(np.bitwise_and(params_dic["modes"]["params"][pos_l[2],  col_f] >=freq_range[0], params_dic["modes"]["params"][pos_l[2],  col_f]<=freq_range[1]))[0]))
        NWin.append(len(np.where(np.bitwise_and(params_dic["modes"]["params"][pos_l[3],  col_f] >=freq_range[0], params_dic["modes"]["params"][pos_l[3],  col_f]<=freq_range[1]))[0]))
    else:
        x=freq
        y=spec
        xm=xmodel
        m=model
    if smooth_fact !=None:
        if smooth_fact == 'Auto':
            # Use the average mode width within the show window to get an approximate ideal smooth factor
            f=params_dic["modes"]["params"][:,  col_f]
            w=params_dic["modes"]["params"][:,  col_w]
            pos=np.where(np.bitwise_and(f>=freq_range[0], f<=freq_range[1]))[0]
            smooth_fact=np.mean(w[pos])/4
        #
        resol=freq[1] - freq[0]
        sfactor=int(smooth_fact/resol) # Smooth over smooth_fact, in microHz
        y=gaussian_filter(y, sfactor, mode='mirror')
    # --- Create the main plots ---
    ymin=0 #0.98*np.min(y) # used for the y-scale
    ymax=np.max(y) # used for the y-scale
    len_line_splitting=(ymax-ymin)*6/100 # Size of the lines that show the splitting for a given mode
    #
    ax0.set_xlabel('Frequency ('+r'$\mu$'+ 'Hz)', fontsize=7)
    ax0.set_ylabel('Power' +r'$(ppm^{2}/\mu$' + 'Hz)', fontsize=7)
    ax0.tick_params(axis='x', labelsize=7)
    ax0.tick_params(axis='y', labelsize=7)
    ax0.set_ylim(ymin, ymax)
    ax0.plot(x, y, color='gray', linewidth=0.8) # The data
    ax0.plot(xm, m, color='red', linewidth=0.8) # The model
    if xmodel_ref !=[] and model_ref !=[]:
        ax0.plot(xmodel_ref, model_ref, color='cyan', linewidth=0.6, linestyle='--', alpha=0.7) # The reference model, if specified
    ax0.set_xlim(np.min(x), np.max(x))
    # -------------------------------------------------
    # --- Deal with all of the text in the ax1 zone ---
    # -------------------------------------------------
    if tag_modes == 'all' or tag_modes == 'simple' or tag_modes == 'basic': 
        x0_txt=0.96
        delta_txt=0.125
        ax0.text(0.02, x0_txt, 's = {0:.0f} nHz'.format(smooth_fact*1000) , verticalalignment='bottom', horizontalalignment='left', transform=ax0.transAxes, color='Black', fontsize=7)
        #ax1.text(0.94, x0_txt, 'smooth_fact : {0:.0f} nHz'.format(smooth_fact*1000) , verticalalignment='bottom', horizontalalignment='right', transform=ax1.transAxes, color='red', fontsize=6)
        #ax1.text(0.94, x0_txt-delta_txt, r'$\Delta\nu$ : {0:.3f} +/- {1:0.3f} $\mu$'.format(Dnu, sigDnu) + 'Hz', verticalalignment='bottom', horizontalalignment='right', transform=ax1.transAxes, color='red', fontsize=6)
        #  number of modes:
        # N: Number of mode, at: Median (Med.), Within Current Shown Window (Cur.Win), In Total in the Model (Cur.Tot.)
        #ax1.text(0.94, x0_txt-2*delta_txt, '$N_{l}$   Med.  Cur.Win.  Cur.Tot.', verticalalignment='bottom', horizontalalignment='right', transform=ax1.transAxes, color='blue', fontsize=6)
        #for k in range(len(Nmodes)): 
        #    ax1.text(0.94, x0_txt-(k+3)*delta_txt, '{0:2d}   {1:6}    {2:6}       {3:6}'.format(k, format_numbers(Nmed[k]), format_numbers(NWin[k]), format_numbers(Nmodes[k])), verticalalignment='bottom', horizontalalignment='right', transform=ax1.transAxes, color='blue', fontsize=6)    
        # -------------------------------------------------
    # --- Tagging of the modes ---
    # -------------------------------------------------
    Nrows=len(params_dic["modes"]["params"][:,  0])
    shift1_h=1.3
    shift2_h=0
    shift1_f=1.0
    shift2_f=0
    pc=['blue', 'red', 'purple', 'brown']
    count_l=[0,0,0,0] # Counter for l=0, ... , 3
    for n in range(0, Nrows):
        l=int(params_dic["modes"]["params"][n,  col_l])
        f=params_dic["modes"]["params"][n,  col_f]
        h=params_dic["modes"]["params"][n,  col_h]
        w=params_dic["modes"]["params"][n,  col_w]
        a1=params_dic["modes"]["params"][n,  col_a1]
        inc=params_dic["modes"]["params"][n,  col_inc]
        noise=noise_harvey(f, noise_params[0:-1])
        noise=noise + noise_params[-1]
        count_l[l]=count_l[l] + 1 # Mode by mode counter used for tagging them
        if f >= freq_range[0] and f<= freq_range[1]:
            hlm=amplitude_ratio(l, inc) # assume distribution of amplitudes according to the relation from Gizon between hlm and inclinations
            px=f*shift1_f + shift2_f
            py= h*np.max(hlm)*shift1_h + shift2_h + noise
            if py > ymax: # Readjusting if the text is out of the plot zone
                py=0.95*ymax
            if tag_modes == 'all':
                if tag_modes_on_axis == False:
                    ax0.text(px,py , '{0:.2f}'.format(f) , 
                        verticalalignment='bottom', horizontalalignment='center', color=pc[l], fontsize=4, rotation=90.)#, fontweight='bold')
                else:
                    ax0.text(px,0 , '{0:.2f}'.format(f) , 
                        verticalalignment='top', horizontalalignment='center', color=pc[l], fontsize=4, rotation=75.)
            # Adding ticks proportional to the m-components heights at the bottom the plot and tagging them by index and m. 
            # eg. 1_{+} is the first mode (either l=0, l=1, l=2... using color code) with m=+1. ++ will means m=+2. - means m=-1
            if tag_modes == 'all' or tag_modes == 'simple':
                for m in range(-l, l+1):
                    sm=''
                    is0_shift=0
                    if m==0:
                        sm=count_l[l]
                        is0_shift=0.01*(ymax-ymin)
                    if m >0:
                        for km in range(m):
                            sm=sm+'+'
                    if m <0:
                        for km in range(np.abs(m)):
                            sm=sm+'-'
                    px=f + m*a1
                    py=ymin
                    #py=h*hlm[m+l]*shift1_h + noise
                    ax0.plot([px ,px], [py, py + len_line_splitting*hlm[m+l]], color=pc[l], linewidth=1.)
                    if tag_modes == 'all':
                        ax0.text(px,py + len_line_splitting*hlm[m+l] + 0.01*(ymax-ymin) + is0_shift,  "{}".format(sm), 
                            verticalalignment='center', horizontalalignment='center', color=pc[l], fontsize=4)

        if tag_modes != 'none':
            if inc < 20:
                ax0.text(0.97, 0.82, 'WARNING: inc < 20 deg' , verticalalignment='bottom', horizontalalignment='right', transform=ax0.transAxes, color='blue', fontsize=12, fontweight='bold')
    # ---------------------------
    if do_show == True:
        plt.show()

def show_bestfit(axes, outfile, data_x, data_y, model_x, model_y, params_dic, main_params, inset_params={}):
    '''
        The main function that show the best fit on the top of data
        axes: A 2-element list with the ax of the ploting areas. 
            First element is for the main plot (including inset). Second element is the residual plot
        x: the x-axis values
        y: the y-axis values
        main_params: A dictionary that defines how the main plot is made. List of keys and their goal:
            - 'xmin' and 'xmax': The minimum and maximum value for the ploting area
            - 'scoef' : smoothing coefficient on the data
        inset_params:  A dictionary that defines how the inset plot is made. If empty {}, then no inset is made.
            Keys are the same for the main_params
    '''
    # Make the main zone of plot
    show_model(data_x, data_y, model_x, model_y, params_dic=params_dic, freq_range=[main_params['xmin'], main_params['xmax']], 
                    smooth_fact=main_params['scoef'], ax=[axes[0], axes[0]], tag_modes_on_axis=False, tag_modes='simple')
    # Make the inset if requested
    if inset_params['do_inset'] == True:
        print('include inset')
        ax_inset=axes[0].inset_axes(inset_params['location'])
        show_model(data_x, data_y, model_x, model_y, params_dic=params_dic, freq_range=[inset_params['xmin'], inset_params['xmax']], 
                    smooth_fact=inset_params['scoef'], ax=[ax_inset, ax_inset], tag_modes_on_axis=False, tag_modes='none')
    # Make the residual plot
    show_residual(axes[1], data_x, data_y, model_x, model_y, main_params)
    # Save it
    plt.savefig(outfile, dpi=300)

def main(process_info, rendering_info, outfile, filter_params):
    '''
        The main function to plot
        process_info: A dictionary with all of the required information on the process
                      It must contain: 
            - dir_mcmc: The directory of all the output data
            - process_name: The name of the process. Used to identify the specific MCMC run
            - phase: The phase. Usually either 'B', 'L' or 'A'
            - chain: The chain index. The coldest chain is 0
            - model_name: The name of the model that was executed during the MCMC run
            - data_i_x: The index in the data file at which the x-axis is
            - data_i_y: The index in the data file at which the y-axis is
        rendering_info: A dictionary with all of the required information to render the data
            - Within 'main', keys for:
                - xmin and xmax: The range of the main window
                - scoef: The smoothing coeficient in the main window
            - Within 'inset', keys for:
                - do_inset: A boolean specifying if we render the inset or not
                - xmin and xmax
                - scoef
        outfile: The image output file
    '''
    # Extract all relevant information from the process in order to get the data out and create the 'best' model
    x_data, y_data, x_model, y_model, params_dic=get_model(process_info, filter_params=filter_params, best_criteria='median', phase='A', chain=0, first_index=0, period=2)
    # Define the ploting zones
    fig = plt.figure(layout=None, num=1, clear=True)
    gs = fig.add_gridspec(nrows=11, ncols=1, left=0.1, right=0.90, hspace=0.05, wspace=0.0)
    ax_spec = fig.add_subplot(gs[0:8, 0]) # ZONE FOR SPECTRUM
    ax_residu = fig.add_subplot(gs[8:11, 0]) # ZONE FOR THE RESIDUALS

    # Perform the plots
    show_bestfit([ax_spec, ax_residu], outfile, x_data, y_data, x_model, y_model, params_dic, rendering_info['main'], inset_params=rendering_info['inset'])
